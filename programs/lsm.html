<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>LSM - Building eBPF Programs With Aya</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../intro/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../ebpf/index.html"><strong aria-hidden="true">2.</strong> eBPF Program Constraints</a></li><li class="chapter-item expanded "><a href="../start/index.html"><strong aria-hidden="true">3.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../start/development.html"><strong aria-hidden="true">3.1.</strong> Development Environment</a></li><li class="chapter-item expanded "><a href="../start/hello-xdp.html"><strong aria-hidden="true">3.2.</strong> Hello XDP!</a></li><li class="chapter-item expanded "><a href="../start/logging-packets.html"><strong aria-hidden="true">3.3.</strong> Logging Packets</a></li><li class="chapter-item expanded "><a href="../start/dropping-packets.html"><strong aria-hidden="true">3.4.</strong> Dropping Packets</a></li></ol></li><li class="chapter-item expanded "><a href="../aya/index.html"><strong aria-hidden="true">4.</strong> Working With Aya</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../aya/context.html"><strong aria-hidden="true">4.1.</strong> Reading Values From A Context</a></li><li class="chapter-item expanded "><a href="../aya/aya-gen.html"><strong aria-hidden="true">4.2.</strong> Using aya-gen</a></li><li class="chapter-item expanded "><a href="../aya/aya-log.html"><strong aria-hidden="true">4.3.</strong> Using aya-log</a></li></ol></li><li class="chapter-item expanded "><a href="../programs/index.html"><strong aria-hidden="true">5.</strong> Program Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../programs/probes.html"><strong aria-hidden="true">5.1.</strong> Probes</a></li><li class="chapter-item expanded "><a href="../programs/tracepoints.html"><strong aria-hidden="true">5.2.</strong> Tracepoints</a></li><li class="chapter-item expanded "><a href="../programs/sockets.html"><strong aria-hidden="true">5.3.</strong> Socket Programs</a></li><li class="chapter-item expanded "><a href="../programs/classifiers.html"><strong aria-hidden="true">5.4.</strong> Classifiers</a></li><li class="chapter-item expanded "><a href="../programs/cgroups.html"><strong aria-hidden="true">5.5.</strong> Cgroups</a></li><li class="chapter-item expanded "><a href="../programs/xdp.html"><strong aria-hidden="true">5.6.</strong> XDP</a></li><li class="chapter-item expanded "><a href="../programs/lsm.html" class="active"><strong aria-hidden="true">5.7.</strong> LSM</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Building eBPF Programs With Aya</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="lsm"><a class="header" href="#lsm">LSM</a></h1>
<h2 id="what-is-lsm"><a class="header" href="#what-is-lsm">What is LSM</a></h2>
<p>LSM stands for <a href="https://en.wikipedia.org/wiki/Linux_Security_Modules">Linux Security Modules</a>
which is a framework which allows developers to write security systems on top
of the Linux kernel. It's also briefly described in
<a href="https://www.kernel.org/doc/html/latest/security/lsm.html">the Linux kernel documentation</a>.</p>
<p>LSM is used by kernel modules or (since kernel 5.7) by eBPF programs. The most
popular modules that make use of LSM are AppArmor, SELinux, Smack and TOMOYO.
eBPF LSM programs allow developers to implement the same functionality
implemented by the modules just mentioned, using eBPF APIs.</p>
<p>The central concept behind LSM is <strong>LSM hooks</strong>. LSM hooks are exposed in key
locations in the kernel, and eBPF programs can attach to them to implement
custom security policies. Examples of operations that can be policied via hooks
include:</p>
<ul>
<li>filesystem operations
<ul>
<li>opening, creating, moving and removing files</li>
<li>mounting and unmounting filesystems</li>
</ul>
</li>
<li>task/process operations
<ul>
<li>allocating and freeing tasks, changing user and group identify for a task</li>
</ul>
</li>
<li>socket operations
<ul>
<li>creating and binding sockets</li>
<li>receiving and sending messages</li>
</ul>
</li>
</ul>
<p>Each of those actions has a corresponding LSM hook. All LSM hooks are listed in
the <a href="https://github.com/torvalds/linux/blob/master/include/linux/lsm_hooks.h">lsm_hooks.h</a>
header inside the Linux kernel source code. Each hook takes a number of
arguments, which provide context based on which programs can implement policy
decisions and are listed in the
<a href="https://github.com/torvalds/linux/blob/master/include/linux/lsm_hook_defs.h">lsm_hook_defs.h</a>
header.</p>
<p>For example, consider the <code>task_setnice</code> hook, which has the following
definition:</p>
<pre><code class="language-c">LSM_HOOK(int, 0, task_setnice, struct task_struct *p, int nice)
</code></pre>
<p>The hook is triggered when a nice value is set for any process in the system.
If you are not familiar with the concept of process niceness, check out
<a href="https://en.wikipedia.org/wiki/Nice_(Unix)">this article</a>. As you can see from
the definition, this hook takes the following arguments:</p>
<ul>
<li><code>p</code> is the instance of <code>task_struct</code> which represents the process on which
the nice value is set</li>
<li><code>nice</code> is the nice value</li>
</ul>
<p>By attaching to the hook, an eBPF program can decide whether to accept or
reject the given nice value.</p>
<p>In addition to the arguments found in the hook definition, eBPF programs have
access to one extra argument - <code>ret</code> - which is a return value of potential
previous eBPF LSM programs.</p>
<h2 id="writing-lsm-bpf-program"><a class="header" href="#writing-lsm-bpf-program">Writing LSM BPF program</a></h2>
<p>Let's try to create an LSM eBPF program which which is triggered by
<code>task_setnice</code> hook. The purpose of this program will be denying setting the
nice value lower than 0 (which means higher priority), for a particular process.</p>
<p>The <code>renice</code> tool can be used to change niceness values:</p>
<pre><code class="language-bash">renice [value] -p [pid]
</code></pre>
<p>With our eBPF program, we want to make it impossible to call <code>renice</code> for a
given <code>pid</code> with a negative <code>[value]</code>.</p>
<p>eBPF projects come with two parts: eBPF program(s) and the userspace program.
To make our example simple, we can try to deny a change of a nice value of
the userspace process which loads the eBPF program.</p>
<p>The first step is to create a new project:</p>
<pre><code class="language-bash">cargo generate --name lsm-nice -d program_type=lsm -d lsm_hook=task_setnice https://github.com/aya-rs/aya-template
</code></pre>
<p>That command should create a new Aya project with an empty program attaching to
the <code>task_setnice</code> hook. Let's go to its directory:</p>
<pre><code class="language-bash">cd lsm-mount
</code></pre>
<p>One of the arguments passed to the <code>task_setnice</code> hook is a pointer to a
<a href="https://elixir.bootlin.com/linux/v5.15.3/source/include/linux/sched.h#L723">task_struct type</a>.
Therefore we need to generate a binding to <code>task_struct</code> with aya-gen.</p>
<blockquote>
<p>If you are not familiar with aya-gen, please refer to
<a href="../aya/aya-gen.html">this section</a>.</p>
</blockquote>
<pre><code class="language-bash">aya-gen generate task_struct &gt; lsm-nice-ebpf/src/vmlinux.rs
</code></pre>
<p>Now it's time to modify the <code>lsm-nice-ebpf</code> project and write an actual program
there. The full program code should look like:</p>
<pre><code class="language-rust ignore">#![no_std]
#![no_main]

use aya_bpf::{cty::c_int, macros::lsm, programs::LsmContext};

#[allow(non_upper_case_globals)]
#[allow(non_snake_case)]
#[allow(non_camel_case_types)]
#[allow(dead_code)]
mod vmlinux;

use vmlinux::task_struct;

/// PID of the process for which setting a negative nice value is denied.
#[no_mangle]
static PID: i32 = 0;

#[lsm(name = &quot;task_setnice&quot;)]
pub fn task_setnice(ctx: LsmContext) -&gt; i32 {
    match unsafe { try_task_setnice(ctx) } {
        Ok(ret) =&gt; ret,
        Err(ret) =&gt; ret,
    }
}

unsafe fn try_task_setnice(ctx: LsmContext) -&gt; Result&lt;i32, i32&gt; {
    let p: *const task_struct = ctx.arg(0);
    let nice: c_int = ctx.arg(1);
    let ret: c_int = ctx.arg(2);

    // If previous eBPF LSM program didn't allow the action, return the
    // previous error code.
    if ret != 0 {
        return Err(ret);
    }

    // Deny setting the nice value lower than 0 for the defined PID.
    if (*p).pid == core::ptr::read_volatile(&amp;PID) &amp;&amp; nice &lt; 0 {
        return Err(-1);
    }

    // Otherwise allow it.
    Ok(0)
}

#[panic_handler]
fn panic(_info: &amp;core::panic::PanicInfo) -&gt; ! {
    unsafe { core::hint::unreachable_unchecked() }
}
</code></pre>
<p>Let's look at the code in detail.</p>
<p>At the beginning, we include the autogenerated binding to <code>task_struct</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">#![no_std]
</span><span class="boring">#![no_main]
</span><span class="boring">
</span><span class="boring">use aya_bpf::{cty::c_int, macros::lsm, programs::LsmContext};
</span><span class="boring">
</span>#[allow(non_upper_case_globals)]
#[allow(non_snake_case)]
#[allow(non_camel_case_types)]
#[allow(dead_code)]
mod vmlinux;

use vmlinux::task_struct;
<span class="boring">
</span><span class="boring">/// PID of the process for which setting a negative nice value is denied.
</span><span class="boring">#[no_mangle]
</span><span class="boring">static PID: i32 = 0;
</span><span class="boring">
</span><span class="boring">#[lsm(name = &quot;task_setnice&quot;)]
</span><span class="boring">pub fn task_setnice(ctx: LsmContext) -&gt; i32 {
</span><span class="boring">    match unsafe { try_task_setnice(ctx) } {
</span><span class="boring">        Ok(ret) =&gt; ret,
</span><span class="boring">        Err(ret) =&gt; ret,
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">unsafe fn try_task_setnice(ctx: LsmContext) -&gt; Result&lt;i32, i32&gt; {
</span><span class="boring">    let p: *const task_struct = ctx.arg(0);
</span><span class="boring">    let nice: c_int = ctx.arg(1);
</span><span class="boring">    let ret: c_int = ctx.arg(2);
</span><span class="boring">
</span><span class="boring">    // If previous eBPF LSM program didn't allow the action, return the
</span><span class="boring">    // previous error code.
</span><span class="boring">    if ret != 0 {
</span><span class="boring">        return Err(ret);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Deny setting the nice value lower than 0 for the defined PID.
</span><span class="boring">    if (*p).pid == core::ptr::read_volatile(&amp;PID) &amp;&amp; nice &lt; 0 {
</span><span class="boring">        return Err(-1);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Otherwise allow it.
</span><span class="boring">    Ok(0)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[panic_handler]
</span><span class="boring">fn panic(_info: &amp;core::panic::PanicInfo) -&gt; ! {
</span><span class="boring">    unsafe { core::hint::unreachable_unchecked() }
</span><span class="boring">}
</span></code></pre>
<p>Then we define a global variable <code>PID</code>. We initialize the value to 0, but at
runtime the userspace side will patch the value with the actual pid we're
interested in.</p>
<pre><code class="language-rust ignore"><span class="boring">#![no_std]
</span><span class="boring">#![no_main]
</span><span class="boring">
</span><span class="boring">use aya_bpf::{cty::c_int, macros::lsm, programs::LsmContext};
</span><span class="boring">
</span><span class="boring">#[allow(non_upper_case_globals)]
</span><span class="boring">#[allow(non_snake_case)]
</span><span class="boring">#[allow(non_camel_case_types)]
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">mod vmlinux;
</span><span class="boring">
</span><span class="boring">use vmlinux::task_struct;
</span><span class="boring">
</span>/// PID of the process for which setting a negative nice value is denied.
#[no_mangle]
static PID: i32 = 0;
<span class="boring">
</span><span class="boring">#[lsm(name = &quot;task_setnice&quot;)]
</span><span class="boring">pub fn task_setnice(ctx: LsmContext) -&gt; i32 {
</span><span class="boring">    match unsafe { try_task_setnice(ctx) } {
</span><span class="boring">        Ok(ret) =&gt; ret,
</span><span class="boring">        Err(ret) =&gt; ret,
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">unsafe fn try_task_setnice(ctx: LsmContext) -&gt; Result&lt;i32, i32&gt; {
</span><span class="boring">    let p: *const task_struct = ctx.arg(0);
</span><span class="boring">    let nice: c_int = ctx.arg(1);
</span><span class="boring">    let ret: c_int = ctx.arg(2);
</span><span class="boring">
</span><span class="boring">    // If previous eBPF LSM program didn't allow the action, return the
</span><span class="boring">    // previous error code.
</span><span class="boring">    if ret != 0 {
</span><span class="boring">        return Err(ret);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Deny setting the nice value lower than 0 for the defined PID.
</span><span class="boring">    if (*p).pid == core::ptr::read_volatile(&amp;PID) &amp;&amp; nice &lt; 0 {
</span><span class="boring">        return Err(-1);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Otherwise allow it.
</span><span class="boring">    Ok(0)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[panic_handler]
</span><span class="boring">fn panic(_info: &amp;core::panic::PanicInfo) -&gt; ! {
</span><span class="boring">    unsafe { core::hint::unreachable_unchecked() }
</span><span class="boring">}
</span></code></pre>
<p>And finally we have the program and the logic what to do with nice values.</p>
<pre><code class="language-rust ignore"><span class="boring">#![no_std]
</span><span class="boring">#![no_main]
</span><span class="boring">
</span><span class="boring">use aya_bpf::{cty::c_int, macros::lsm, programs::LsmContext};
</span><span class="boring">
</span><span class="boring">#[allow(non_upper_case_globals)]
</span><span class="boring">#[allow(non_snake_case)]
</span><span class="boring">#[allow(non_camel_case_types)]
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">mod vmlinux;
</span><span class="boring">
</span><span class="boring">use vmlinux::task_struct;
</span><span class="boring">
</span><span class="boring">/// PID of the process for which setting a negative nice value is denied.
</span><span class="boring">#[no_mangle]
</span><span class="boring">static PID: i32 = 0;
</span><span class="boring">
</span><span class="boring">#[lsm(name = &quot;task_setnice&quot;)]
</span><span class="boring">pub fn task_setnice(ctx: LsmContext) -&gt; i32 {
</span><span class="boring">    match unsafe { try_task_setnice(ctx) } {
</span><span class="boring">        Ok(ret) =&gt; ret,
</span><span class="boring">        Err(ret) =&gt; ret,
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>unsafe fn try_task_setnice(ctx: LsmContext) -&gt; Result&lt;i32, i32&gt; {
    let p: *const task_struct = ctx.arg(0);
    let nice: c_int = ctx.arg(1);
    let ret: c_int = ctx.arg(2);

    // If previous eBPF LSM program didn't allow the action, return the
    // previous error code.
    if ret != 0 {
        return Err(ret);
    }

    // Deny setting the nice value lower than 0 for the defined PID.
    if (*p).pid == core::ptr::read_volatile(&amp;PID) &amp;&amp; nice &lt; 0 {
        return Err(-1);
    }

    // Otherwise allow it.
    Ok(0)
}
<span class="boring">
</span><span class="boring">#[panic_handler]
</span><span class="boring">fn panic(_info: &amp;core::panic::PanicInfo) -&gt; ! {
</span><span class="boring">    unsafe { core::hint::unreachable_unchecked() }
</span><span class="boring">}
</span></code></pre>
<p>After that we also need to modify the userspace part. We don't need as much
work as with the eBPF part, but we need to:</p>
<ol>
<li>Get the PID.</li>
<li>Log it.</li>
<li>Write it to the global variable in the eBPF object.</li>
</ol>
<p>The final result should look like:</p>
<pre><code class="language-rust ignore">use std::process;

use aya::{include_bytes_aligned, BpfLoader};
use aya::{programs::Lsm, Btf};
use log::info;
use simplelog::{ColorChoice, ConfigBuilder, LevelFilter, TermLogger, TerminalMode};
use tokio::signal;

#[tokio::main]
async fn main() -&gt; Result&lt;(), anyhow::Error&gt; {
    TermLogger::init(
        LevelFilter::Debug,
        ConfigBuilder::new()
            .set_target_level(LevelFilter::Error)
            .set_location_level(LevelFilter::Error)
            .build(),
        TerminalMode::Mixed,
        ColorChoice::Auto,
    )?;

    let pid = process::id() as i32;
    info!(&quot;PID: {}&quot;, pid);

    // This will include your eBPF object file as raw bytes at compile-time and load it at
    // runtime. This approach is recommended for most real-world use cases. If you would
    // like to specify the eBPF program at runtime rather than at compile-time, you can
    // reach for `Bpf::load_file` instead.
    let mut bpf = BpfLoader::new().set_global(&quot;PID&quot;, &amp;pid).load(include_bytes_aligned!(
        &quot;../../target/bpfel-unknown-none/release/lsm-nice&quot;
    ))?;
    let btf = Btf::from_sys_fs()?;
    let program: &amp;mut Lsm = bpf.program_mut(&quot;task_setnice&quot;).unwrap().try_into()?;
    program.load(&quot;task_setnice&quot;, &amp;btf)?;
    program.attach()?;

    info!(&quot;Waiting for Ctrl-C...&quot;);
    signal::ctrl_c().await?;
    info!(&quot;Exiting...&quot;);

    Ok(())
}
</code></pre>
<p>Where we start with getting and logging a PID:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use aya::{include_bytes_aligned, BpfLoader};
</span><span class="boring">use aya::{programs::Lsm, Btf};
</span><span class="boring">use log::info;
</span><span class="boring">use simplelog::{ColorChoice, ConfigBuilder, LevelFilter, TermLogger, TerminalMode};
</span><span class="boring">use tokio::signal;
</span><span class="boring">
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() -&gt; Result&lt;(), anyhow::Error&gt; {
</span><span class="boring">    TermLogger::init(
</span><span class="boring">        LevelFilter::Debug,
</span><span class="boring">        ConfigBuilder::new()
</span><span class="boring">            .set_target_level(LevelFilter::Error)
</span><span class="boring">            .set_location_level(LevelFilter::Error)
</span><span class="boring">            .build(),
</span><span class="boring">        TerminalMode::Mixed,
</span><span class="boring">        ColorChoice::Auto,
</span><span class="boring">    )?;
</span><span class="boring">
</span>    let pid = process::id() as i32;
    info!(&quot;PID: {}&quot;, pid);
<span class="boring">
</span><span class="boring">    // This will include your eBPF object file as raw bytes at compile-time and load it at
</span><span class="boring">    // runtime. This approach is recommended for most real-world use cases. If you would
</span><span class="boring">    // like to specify the eBPF program at runtime rather than at compile-time, you can
</span><span class="boring">    // reach for `Bpf::load_file` instead.
</span><span class="boring">    let mut bpf = BpfLoader::new().set_global(&quot;PID&quot;, &amp;pid).load(include_bytes_aligned!(
</span><span class="boring">        &quot;../../target/bpfel-unknown-none/release/lsm-nice&quot;
</span><span class="boring">    ))?;
</span><span class="boring">    let btf = Btf::from_sys_fs()?;
</span><span class="boring">    let program: &amp;mut Lsm = bpf.program_mut(&quot;task_setnice&quot;).unwrap().try_into()?;
</span><span class="boring">    program.load(&quot;task_setnice&quot;, &amp;btf)?;
</span><span class="boring">    program.attach()?;
</span><span class="boring">
</span><span class="boring">    info!(&quot;Waiting for Ctrl-C...&quot;);
</span><span class="boring">    signal::ctrl_c().await?;
</span><span class="boring">    info!(&quot;Exiting...&quot;);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span></code></pre>
<p>And then we set the global variable:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use aya::{include_bytes_aligned, BpfLoader};
</span><span class="boring">use aya::{programs::Lsm, Btf};
</span><span class="boring">use log::info;
</span><span class="boring">use simplelog::{ColorChoice, ConfigBuilder, LevelFilter, TermLogger, TerminalMode};
</span><span class="boring">use tokio::signal;
</span><span class="boring">
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() -&gt; Result&lt;(), anyhow::Error&gt; {
</span><span class="boring">    TermLogger::init(
</span><span class="boring">        LevelFilter::Debug,
</span><span class="boring">        ConfigBuilder::new()
</span><span class="boring">            .set_target_level(LevelFilter::Error)
</span><span class="boring">            .set_location_level(LevelFilter::Error)
</span><span class="boring">            .build(),
</span><span class="boring">        TerminalMode::Mixed,
</span><span class="boring">        ColorChoice::Auto,
</span><span class="boring">    )?;
</span><span class="boring">
</span><span class="boring">    let pid = process::id() as i32;
</span><span class="boring">    info!(&quot;PID: {}&quot;, pid);
</span><span class="boring">
</span><span class="boring">    // This will include your eBPF object file as raw bytes at compile-time and load it at
</span><span class="boring">    // runtime. This approach is recommended for most real-world use cases. If you would
</span><span class="boring">    // like to specify the eBPF program at runtime rather than at compile-time, you can
</span><span class="boring">    // reach for `Bpf::load_file` instead.
</span>    let mut bpf = BpfLoader::new().set_global(&quot;PID&quot;, &amp;pid).load(include_bytes_aligned!(
        &quot;../../target/bpfel-unknown-none/release/lsm-nice&quot;
    ))?;
<span class="boring">    let btf = Btf::from_sys_fs()?;
</span><span class="boring">    let program: &amp;mut Lsm = bpf.program_mut(&quot;task_setnice&quot;).unwrap().try_into()?;
</span><span class="boring">    program.load(&quot;task_setnice&quot;, &amp;btf)?;
</span><span class="boring">    program.attach()?;
</span><span class="boring">
</span><span class="boring">    info!(&quot;Waiting for Ctrl-C...&quot;);
</span><span class="boring">    signal::ctrl_c().await?;
</span><span class="boring">    info!(&quot;Exiting...&quot;);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span></code></pre>
<p>After that, we can build and run our project with:</p>
<pre><code class="language-bash">cargo xtask build-ebpf
cargo xtask run
</code></pre>
<p>The output should contain our log line showing the PID of the userspace
process, i.e.:</p>
<pre><code class="language-bash">16:32:30 [INFO] lsm_nice: [lsm-nice/src/main.rs:22] PID: 573354
</code></pre>
<p>Now we can try to change the nice value for that process. Setting a positive
value (lowering the priority) should still work:</p>
<pre><code class="language-bash"># renice 10 -p 587184
587184 (process ID) old priority 0, new priority 10
</code></pre>
<p>But setting a negative value should not be allowed:</p>
<pre><code class="language-bash"># renice -10 -p 587184
renice: failed to set priority for 587184 (process ID): Operation not permitted
</code></pre>
<p>If doing that resulted in <code>Operation not permitted</code>, congratulations, your LSM
eBPF program works!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../programs/xdp.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../programs/xdp.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
